using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Cimian.CLI.Cimipkg.Models;
using Microsoft.Extensions.Logging;

namespace Cimian.CLI.Cimipkg.Services;

/// <summary>
/// Generates Chocolatey-compatible scripts and .nuspec files for .nupkg packages.
/// </summary>
public class ChocolateyGenerator
{
    private readonly ILogger<ChocolateyGenerator> _logger;
    private readonly ScriptProcessor _scriptProcessor;

    public ChocolateyGenerator(ILogger<ChocolateyGenerator> logger, ScriptProcessor scriptProcessor)
    {
        _logger = logger;
        _scriptProcessor = scriptProcessor;
    }

    /// <summary>
    /// Creates the chocolateyInstall.ps1 script for a package.
    /// </summary>
    /// <param name="buildInfo">Build information from build-info.yaml.</param>
    /// <param name="projectDir">Path to the project directory.</param>
    /// <param name="toolsDir">Path to the tools directory.</param>
    /// <param name="isInstallerPackage">Whether this is an installer package.</param>
    /// <param name="hasPayloadFiles">Whether the payload directory has files.</param>
    /// <param name="envVars">Environment variables for placeholder replacement.</param>
    public void CreateChocolateyInstallScript(
        BuildInfo buildInfo,
        string projectDir,
        string toolsDir,
        bool isInstallerPackage,
        bool hasPayloadFiles,
        IDictionary<string, string> envVars)
    {
        var sb = new StringBuilder();

        // Add standard header
        sb.AppendLine(@"# chocolateyInstall.ps1 - Generated by cimipkg
$ErrorActionPreference = 'Stop'

# Set up common variables
$toolsDir = ""$(Split-Path -Parent $MyInvocation.MyCommand.Definition)""
$payloadDir = Join-Path $toolsDir ""payload""
$payloadRoot = $payloadDir  # Alias for compatibility
");

        // Add install location if specified
        if (!string.IsNullOrEmpty(buildInfo.InstallLocation))
        {
            sb.AppendLine($@"$installLocation = ""{EscapePowerShellString(buildInfo.InstallLocation)}""
");
        }

        // Include preinstall scripts
        var scriptsDir = Path.Combine(projectDir, "scripts");
        var preinstallScripts = _scriptProcessor.GetPreinstallScripts(scriptsDir);
        foreach (var preinstallScript in preinstallScripts)
        {
            var content = File.ReadAllText(preinstallScript, Encoding.UTF8);
            content = _scriptProcessor.ReplacePlaceholders(content, envVars);
            sb.AppendLine($"# === Preinstall: {Path.GetFileName(preinstallScript)} ===");
            sb.AppendLine(content);
            sb.AppendLine();
            _logger.LogDebug("Included preinstall script: {Script}", Path.GetFileName(preinstallScript));
        }

        if (isInstallerPackage)
        {
            // Generate installer package script
            GenerateInstallerScript(sb, buildInfo, projectDir);
        }
        else if (hasPayloadFiles)
        {
            // Generate payload copy script
            GeneratePayloadCopyScript(sb, buildInfo);
        }

        // Include postinstall scripts
        var postinstallScripts = _scriptProcessor.GetPostinstallScripts(scriptsDir);
        foreach (var postinstallScript in postinstallScripts)
        {
            var content = File.ReadAllText(postinstallScript, Encoding.UTF8);
            content = _scriptProcessor.ReplacePlaceholders(content, envVars);
            sb.AppendLine($"# === Postinstall: {Path.GetFileName(postinstallScript)} ===");
            sb.AppendLine(content);
            sb.AppendLine();
            _logger.LogDebug("Included postinstall script: {Script}", Path.GetFileName(postinstallScript));
        }

        // Add postinstall action if specified
        GeneratePostinstallAction(sb, buildInfo.PostinstallAction);

        // Write the script
        var chocolateyInstallPath = Path.Combine(toolsDir, "chocolateyInstall.ps1");
        File.WriteAllText(chocolateyInstallPath, sb.ToString(), Encoding.UTF8);
        _logger.LogInformation("Created chocolateyInstall.ps1");
    }

    /// <summary>
    /// Creates the chocolateyUninstall.ps1 script for a package.
    /// </summary>
    public void CreateChocolateyUninstallScript(
        BuildInfo buildInfo,
        string projectDir,
        string toolsDir,
        bool isInstallerPackage,
        IDictionary<string, string> envVars)
    {
        var sb = new StringBuilder();

        sb.AppendLine(@"# chocolateyUninstall.ps1 - Generated by cimipkg
$ErrorActionPreference = 'Stop'

# Set up common variables
$toolsDir = ""$(Split-Path -Parent $MyInvocation.MyCommand.Definition)""
");

        // Check for custom uninstall script
        var scriptsDir = Path.Combine(projectDir, "scripts");
        var uninstallScript = _scriptProcessor.GetUninstallScript(scriptsDir);

        if (buildInfo.OverrideUninstallScript && uninstallScript != null)
        {
            // Use custom uninstall script entirely
            var content = File.ReadAllText(uninstallScript, Encoding.UTF8);
            content = _scriptProcessor.ReplacePlaceholders(content, envVars);
            sb.AppendLine("# === Custom Uninstall Script ===");
            sb.AppendLine(content);
            _logger.LogDebug("Using override uninstall script");
        }
        else
        {
            if (isInstallerPackage)
            {
                // Generate uninstaller invocation
                GenerateUninstallerScript(sb, buildInfo);
            }

            // Append custom uninstall script if exists
            if (uninstallScript != null)
            {
                var content = File.ReadAllText(uninstallScript, Encoding.UTF8);
                content = _scriptProcessor.ReplacePlaceholders(content, envVars);
                sb.AppendLine("# === Additional Uninstall Script ===");
                sb.AppendLine(content);
                _logger.LogDebug("Appended custom uninstall script");
            }
        }

        // Write the script
        var chocolateyUninstallPath = Path.Combine(toolsDir, "chocolateyUninstall.ps1");
        File.WriteAllText(chocolateyUninstallPath, sb.ToString(), Encoding.UTF8);
        _logger.LogInformation("Created chocolateyUninstall.ps1");
    }

    /// <summary>
    /// Generates the .nuspec file for a package.
    /// </summary>
    public string GenerateNuspec(BuildInfo buildInfo, string projectDir)
    {
        var nuspecPath = Path.Combine(projectDir, $"{buildInfo.Product.Identifier}.nuspec");

        var sb = new StringBuilder();
        sb.AppendLine(@"<?xml version=""1.0"" encoding=""utf-8""?>");
        sb.AppendLine(@"<package xmlns=""http://schemas.microsoft.com/packaging/2015/06/nuspec.xsd"">");
        sb.AppendLine(@"  <metadata>");
        sb.AppendLine($@"    <id>{EscapeXml(buildInfo.Product.Identifier)}</id>");
        sb.AppendLine($@"    <version>{EscapeXml(buildInfo.Product.Version)}</version>");
        sb.AppendLine($@"    <title>{EscapeXml(buildInfo.Product.Name)}</title>");
        sb.AppendLine($@"    <authors>{EscapeXml(buildInfo.Product.Developer ?? "Unknown")}</authors>");
        sb.AppendLine($@"    <owners>{EscapeXml(buildInfo.Product.Developer ?? "Unknown")}</owners>");

        if (!string.IsNullOrEmpty(buildInfo.Description))
        {
            sb.AppendLine($@"    <description>{EscapeXml(buildInfo.Description)}</description>");
        }
        else
        {
            sb.AppendLine($@"    <description>{EscapeXml(buildInfo.Product.Name)} package</description>");
        }

        if (!string.IsNullOrEmpty(buildInfo.Product.Url))
        {
            sb.AppendLine($@"    <projectUrl>{EscapeXml(buildInfo.Product.Url)}</projectUrl>");
        }

        if (!string.IsNullOrEmpty(buildInfo.Icon))
        {
            sb.AppendLine($@"    <iconUrl>{EscapeXml(buildInfo.Icon)}</iconUrl>");
        }

        if (!string.IsNullOrEmpty(buildInfo.Product.License))
        {
            sb.AppendLine($@"    <licenseUrl>{EscapeXml(buildInfo.Product.License)}</licenseUrl>");
        }

        if (!string.IsNullOrEmpty(buildInfo.Product.Copyright))
        {
            sb.AppendLine($@"    <copyright>{EscapeXml(buildInfo.Product.Copyright)}</copyright>");
        }

        if (buildInfo.Product.Tags != null && buildInfo.Product.Tags.Count > 0)
        {
            sb.AppendLine($@"    <tags>{EscapeXml(string.Join(" ", buildInfo.Product.Tags))}</tags>");
        }

        sb.AppendLine(@"    <requireLicenseAcceptance>false</requireLicenseAcceptance>");
        sb.AppendLine(@"  </metadata>");
        sb.AppendLine(@"  <files>");
        sb.AppendLine(@"    <file src=""tools\**"" target=""tools"" />");
        sb.AppendLine(@"  </files>");
        sb.AppendLine(@"</package>");

        File.WriteAllText(nuspecPath, sb.ToString(), Encoding.UTF8);
        _logger.LogInformation("Generated .nuspec at: {NuspecPath}", nuspecPath);

        return nuspecPath;
    }

    /// <summary>
    /// Generates installer-specific script content.
    /// </summary>
    private void GenerateInstallerScript(StringBuilder sb, BuildInfo buildInfo, string projectDir)
    {
        var installerType = buildInfo.Product.InstallerType?.ToLowerInvariant() ?? "exe";

        // Find installer file in payload
        sb.AppendLine("# Find installer in payload");
        sb.AppendLine(@"$installerFile = Get-ChildItem -Path $payloadDir -Filter ""*.$installerType"" | Select-Object -First 1");
        sb.AppendLine(@"if (-not $installerFile) {");
        sb.AppendLine($@"    $installerFile = Get-ChildItem -Path $payloadDir -Filter ""*.{installerType}"" | Select-Object -First 1");
        sb.AppendLine(@"}");
        sb.AppendLine(@"if (-not $installerFile) {");
        sb.AppendLine(@"    throw ""No installer file found in payload directory""");
        sb.AppendLine(@"}");
        sb.AppendLine();

        // Set up install arguments
        var installArgs = buildInfo.InstallArguments ?? GetDefaultInstallArgs(installerType);
        var validExitCodes = buildInfo.ValidExitCodes ?? "0,3010";

        sb.AppendLine($@"$installArgs = ""{EscapePowerShellString(installArgs)}""");
        sb.AppendLine($@"$validExitCodes = @({validExitCodes})");
        sb.AppendLine();

        // Run installer
        if (installerType == "msi")
        {
            sb.AppendLine(@"Write-Host ""Installing MSI: $($installerFile.FullName)""");
            sb.AppendLine(@"$process = Start-Process -FilePath ""msiexec.exe"" -ArgumentList ""/i `""$($installerFile.FullName)`"" $installArgs"" -Wait -PassThru -NoNewWindow");
        }
        else
        {
            sb.AppendLine(@"Write-Host ""Installing: $($installerFile.FullName)""");
            sb.AppendLine(@"$process = Start-Process -FilePath $installerFile.FullName -ArgumentList $installArgs -Wait -PassThru -NoNewWindow");
        }

        sb.AppendLine(@"
if ($validExitCodes -notcontains $process.ExitCode) {
    throw ""Installer failed with exit code: $($process.ExitCode)""
}
Write-Host ""Installation completed with exit code: $($process.ExitCode)""
");
    }

    /// <summary>
    /// Generates payload copy script content.
    /// </summary>
    private void GeneratePayloadCopyScript(StringBuilder sb, BuildInfo buildInfo)
    {
        if (string.IsNullOrEmpty(buildInfo.InstallLocation))
        {
            throw new InvalidOperationException("InstallLocation is required when payload exists and not an installer package.");
        }

        sb.AppendLine("# Copy payload to install location");
        sb.AppendLine($@"$installLocation = ""{EscapePowerShellString(buildInfo.InstallLocation)}""");
        sb.AppendLine(@"
if ($installLocation -and -not ($installLocation -match '^[A-Za-z]:\\?$')) {
    New-Item -ItemType Directory -Force -Path $installLocation | Out-Null
}

Write-Host ""Copying payload to: $installLocation""
Get-ChildItem -Path $payloadRoot -Recurse | ForEach-Object {
    $fullName = $_.FullName
    $fullName = [Management.Automation.WildcardPattern]::Escape($fullName)
    $relative = $fullName.Substring($payloadRoot.Length).TrimStart('\','/')
    $dest     = Join-Path $installLocation $relative

    if ($_.PSIsContainer) {
        if (-not ($dest -match '^[A-Za-z]:\\?$')) {
            New-Item -ItemType Directory -Force -Path $dest | Out-Null
        }
    } else {
        $parentDir = Split-Path $dest -Parent
        if ($parentDir -and -not ($parentDir -match '^[A-Za-z]:\\?$') -and -not (Test-Path -LiteralPath $parentDir)) {
            New-Item -ItemType Directory -Force -Path $parentDir | Out-Null
        }
        Copy-Item -LiteralPath $fullName -Destination $dest -Force
        if (-not (Test-Path -LiteralPath $dest)) {
            Write-Error ""Failed to copy $fullName""
            exit 1
        }
    }
}
Write-Host ""Payload copied successfully""
");
    }

    /// <summary>
    /// Generates postinstall action script content.
    /// </summary>
    private void GeneratePostinstallAction(StringBuilder sb, string? postinstallAction)
    {
        if (string.IsNullOrWhiteSpace(postinstallAction) || postinstallAction == "none")
        {
            return;
        }

        sb.AppendLine("# Postinstall action");
        switch (postinstallAction.ToLowerInvariant())
        {
            case "logout":
                sb.AppendLine(@"Write-Host ""Postinstall action: logout""");
                sb.AppendLine(@"# Note: Actual logout is typically handled by the deployment system");
                break;

            case "restart":
            case "reboot":
                sb.AppendLine(@"Write-Host ""Postinstall action: restart""");
                sb.AppendLine(@"# Note: Actual restart is typically handled by the deployment system");
                break;

            case "shutdown":
                sb.AppendLine(@"Write-Host ""Postinstall action: shutdown""");
                sb.AppendLine(@"# Note: Actual shutdown is typically handled by the deployment system");
                break;
        }
        sb.AppendLine();
    }

    /// <summary>
    /// Generates uninstaller script content.
    /// </summary>
    private void GenerateUninstallerScript(StringBuilder sb, BuildInfo buildInfo)
    {
        var installerType = buildInfo.Product.InstallerType?.ToLowerInvariant() ?? "exe";
        var uninstallArgs = buildInfo.UninstallArguments ?? GetDefaultUninstallArgs(installerType);

        sb.AppendLine("# Uninstall package");

        if (!string.IsNullOrEmpty(buildInfo.SoftwareDetection))
        {
            // Use registry detection to find uninstall string
            sb.AppendLine($@"$softwareDisplayName = ""{EscapePowerShellString(buildInfo.SoftwareDetection)}""");
            sb.AppendLine(@"
$uninstallKeys = @(
    'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*',
    'HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*'
)

$software = Get-ItemProperty $uninstallKeys -ErrorAction SilentlyContinue | 
    Where-Object { $_.DisplayName -like ""*$softwareDisplayName*"" } |
    Select-Object -First 1

if ($software) {
    Write-Host ""Found software: $($software.DisplayName)""
    $uninstallString = $software.UninstallString
    if ($uninstallString) {
        Write-Host ""Running uninstaller: $uninstallString""
        Start-Process -FilePath ""cmd.exe"" -ArgumentList ""/c $uninstallString"" -Wait -NoNewWindow
    }
} else {
    Write-Host ""Software not found in registry""
}
");
        }
        else
        {
            sb.AppendLine("Write-Host \"No software detection configured - uninstall may require manual steps\"");
        }
    }

    /// <summary>
    /// Gets default install arguments for an installer type.
    /// </summary>
    private static string GetDefaultInstallArgs(string installerType)
    {
        return installerType switch
        {
            "msi" => "/qn /norestart ALLUSERS=1",
            "exe" => "/S /silent",
            _ => "/S"
        };
    }

    /// <summary>
    /// Gets default uninstall arguments for an installer type.
    /// </summary>
    private static string GetDefaultUninstallArgs(string installerType)
    {
        return installerType switch
        {
            "msi" => "/qn /norestart",
            "exe" => "/S /silent /uninstall",
            _ => "/S"
        };
    }

    /// <summary>
    /// Escapes a string for use in PowerShell.
    /// </summary>
    private static string EscapePowerShellString(string value)
    {
        return value.Replace("`", "``").Replace("\"", "`\"").Replace("$", "`$");
    }

    /// <summary>
    /// Escapes a string for use in XML.
    /// </summary>
    private static string EscapeXml(string value)
    {
        return value
            .Replace("&", "&amp;")
            .Replace("<", "&lt;")
            .Replace(">", "&gt;")
            .Replace("\"", "&quot;")
            .Replace("'", "&apos;");
    }
}
